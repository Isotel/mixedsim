#usage "<h1>Simulate Real Eagle Schematics with Mixed Signal ngSpice</h1>"
        "Version 1.4, 1/4/2018, (c) 2012-2018 Uros Platise, http://www.isotel.eu/mixedsim\n"
        "<p><ul>"
        "Run as: <b>run ngspice</b> [<i>name</i> [<i>sheet number</i> [<i>subckt pin name</i>]]]</ul><p>"
"The ngspice, http://ngspice.org, is a mixed signal simulator "
"embedding spice3f5 (analog), xspice (mixed signal), tclspice (scripting), "
"and allows inclusion of the Verilog-AMS models as well as simulation with the Verilog/VHDL via Yosys synthesis. "
"The xspice adds over 40+ mixed signal analog/digital components to the basic spice. By using "
"CodeModels that can be expanded to your custom models written in C. "
"<p>"
"Purpose of this ngspice script is to use it in a natural way with real circuits to avoid copying and redrawing "
"parts of it for simulation purposes only."
"Netlists are extracted as top or as sub-circuits on detection of at least one "
"sub-circuit port element from the ngspice.lbr."
"In this case script will generate a sub-circuit in a file with .mod extension. "
"Otherwise schematics is extract as top-level circuit with .cir extension. "
"One may specify a design name to be used in output file generation with the first argument in a command line, and "
"optionally it may select a sheet by its number (1, 2, 3, ..) to selectively export only parts of the circuit. "
"Both arguments are given when exporting a part of the circuit to create a sub-circuit. "
"In such cases we would like that this circuit has different ports in spice subckt creation "
"than the whole schematics. This is defined by the 3rd argument, to override the default "
"SPICE-PORT name PINx, to something else, let's say our sheet 5 has a analog filter and we "
"would like to evalute separately, so we name SPICE-PORTs as A1, A2, A3, .. and enter "
"for the last argument the prefix: A"

"<p>"
"Transistors, mosfets, integrated circuits are treated in natural "
"spice way: all primitive elements may be given extra model description, and "
"integrated circuits are included as sub-circuits. So one component (eagle "
"schematics) can be instantiated into the other circuit in a hierarchical way. "
"<p>"
"<b>ChangeLog</b><p>"
"\n\n"
"Version 1.4 1/4/2018<ul>"
"<li>Added more conversions on R,L,C, to handle 3k3 to 3.3k or 4M7 to 4.7Meg"
"<li>Additional in R,L,C that follows after the value are added as comments. Supported delimiters: - , / or space"
"<li>PAD names are sorted to support named PADs, like A,B; whenever alpha characters appear, pad names are put in comment"
"<li>GND is only renamed to net 0 in top-level circuit, and no longer for sub-circuits"
"<li>SPICE_MODEL is made upr case to properly handle SPICE_MODEL=x case"
"</ul>"
"Version 1.3, 6/8/2017<ul>"
"<li>Added external circuit instantiation via Eagle module and port elements"
"<li>Control of parameters from top-level circuit"
"<li>Output file specs with sheet filter"
"<li>Documentation clean-up"
"<li>Uses design name from the arguments when creating subcircuit"
"<li>Exports parameters from SPICE-PARAM parts in top design"
"</ul>"
"Version 1.2, 2016<ul>"
"<li>Added support for code models, mixed signal digital simulation"
"</ul>"
"Version 1.0, 9. March 2014<ul>"
"<li>Extended to sub-circuits, inclusion of custom includes, libs and models"
"<li>Eagle attribute directives to specify titles, author, ..."
"</ul>"
"Version 1.0, 22. August, 2012<ul>"
"<li>First release for top-level circuit used with ngspice-24"
"</ul>"

"<hr>"

"<h2>Top Level Design or a Sub-Circuit Model</h2>"

"A schematics may represent a top-level design exported as .cir, or a sub-circuit "
"model exported as .mod if there is at least one SPICE-PORT instance present from "
"the ngspice.lbr.<p>"

"Top-level design may be run directly while sub-circuit should be instantiated in "
"another circuit, manually in a spice file, or as a component in another eagle "
"schematics hierarchically.<p>"

"When a top-level schematics is detected Auto Generated Sources, are enabled, "
"which are otherwise disabled.</ul><p>"

"The first line in the spice netlist represents the title, which is "
"exported out of the following global attributes:<ul>"
"<li>TITLE, should represent the full description schematic title, and can be placed as >TITLE on your sch<br>"
"<li>DOCNUM, optional parameter and is printed out in ( ... ) after the TITLE,<br>"
"<li>AUTHOR, the main (or the first) author of the schematics<br>"
"<li>CONFIRMED, the responsible person in charge to confirm the schematics (co-author)</ul><p>"

"<h2>Net Labeling</h2>"

"<ul>"
"<li>Net names N$<....> numbered by Eagle are converted as primitive numbers without N$ prefix"
"<li>The net name GND, is converted to 0 only for top-level circuits, in sub-circuit mode remains GND<br>"
"<li>Other exception to these rules are nets defined as +5V, -5V, +12V "
    "which are converted to +5V -> dcp5v, -5V -> dcn5v, dcp12v -> dcn12v when "
    "automatically generated DC supplies are enabled.<br>"
"<li>Other nets are left as on original schematics. You may use any string to "
    "mark a net name, as sum, bus, vin, vout, adout, instead of using numbers."
"</ul>"

"<h2>Unit conversion</h2>"

"Units of the L, C, R devices' values are in addition converted as follows:<ul>"
"<li>if the last character is 'R' it is removed (as 200R -> 200)<br>"
"<li>if the last character is 'M' then it is changed to Meg (as 2M to 2Meg)<br>"
"<li>a small 'm' is left as it is to represent mili<br>"
"<li>forms with k, M and R are converted from like 3k3 to 3.3k, 4M7 to 4.7Meg, 27R2 to 27.2<br>"
"<li>additional comments in values delimited by , - / and space are provided in comments</ul>"
 
"<h2>Auto-Generated Sources</h2>"

"When schematics is a top-level design (without any spice port placed), "
"then the following rules apply:<ul>"

"<li>Net names defined as +5V, -5V, +12V, are renamed "
     "as +5V -> dcp5v, -5V -> dcn5v, +12V -> dcp12v<br>"
"<li>and DC voltage sources are added to the nets automatically."
"</ul>"

"<h2>Primitive (Built-in) Elements</h2>"

"<ul><li>Primitive elements are all spice basic elements and sources. "
    "If name of your part clashes with the spice primitive use SPICE_DEVICE to override it.</ul>"

"<h2>Code Models</h2>"

"<ul><li>Used with the default assignment A<...>, or when attribute spice_cm = ... is given "
        "then the prefix A<...> is used."
"<li>In addition code model definition typically needs a more specific part declaration "
    "that may be added with the spice_model = ... attribute.</ul>"
 
"<h2>Sub-Circuits</h2><ul>"
"<li>Any non-primitive element is treated as a sub-circuit when it is named as X<...> "
    "and it generates an .include statement to include that sub-circuit"
"<li>SPICE_DEVICE=X can be used to set a device a sub-circuit. "
    "In spice code it will appear as XU1 ... if on eagle schematics its name is U1<br>"
"<li>Auto appended prefixes: IC* -> XIC*  example: IC1 will convert as XIC1<br>"
"<li>If additional Attribute is given SPICE_INCLUDE = ... then it overrides the above default<br>"
"<li>include statement is given only once, with the first part<br>"
"<li>Pin numbers define the net order in X<...> net@pin1 net@pin2 <value></ul>"

"<h2>Ignoring Parts</h2><ul>"

"<li>Part can be ignored by placing a SPICE_IGNORE attribute to the part or by setting "
    "part's value to: <b>open</b> or <b>unused</b><br>In all these cases parts "
    "is ignored. Note that SPICE_VALUE overrides the default value of the part.<br>"

"<li>When generating sub-circuit use SPICE_IGNORE attribute as open/unused is not used in the detection.</ul>"
 
"<h2>Schematics as a Sub-circuit</h2><ul>"

"<li>Placing a spice-port from ngspice.lbr with value will create the circuit as a sub-circuit, where "
    "port name defines the pin number and its value a net. Make sure that net matches actual "
    "net name. Port does not need to be physically connected to the net as the script searches for its value only. "
    "But to make a schematics clear, we advise you to draw a net to it.<br>"
"<li>Pin names must be correctly ordered PIN1, PIN2, PIN3, ... etc., however if one is missing "
    "such as PIN1, PIN3, PIN4, ngspice would skip that and produce the interface for the three pins only. "
    "This allows that only one sheet of the circuit is exported for evaluation.<br>"
"<li>Add SPICE_REM attribute to the spice-port to describe the pin, information is added to the sub-circuit header.<br>"
"<li>Any part value which is of form <b>{param}=default</b> will be added to the sub-circuit parameter list as:<br>"
    ".subckt ... param=default, and within the circuit value as {param} will be passed.<br> "
    "More than just one part may use {param} but only one with the default value. For example:<ul>"
    "<li>R1 has value {rin}=1k and R2 has value {2*rin}</ul>"
"</ul>"
    
"<h2>Additional Spice Declarations</h2><ul>"

"<li>Control directives, which are placed at the end of the file generated are "
    "to be placed on the layer with name <b>spice</b> or <b>ngspice</b> or <b>ngspice-control</b>.<br>"
"<li>Control directives, which are placed at the beginning of the file, are to "
    "be placed on the layer with name <b>ngspice-init</b></ul>"
 
"<h2>Attributes Reference List</h2><ul>"

"<li><b>SPICE_DEVICE  = A, U, R, etc.</b> overrides default device naming policy in such a way that "
"the new prefix is added at the front of the actual part number, "
"so the uniqueness overall circuit is 100% preserved, i.e. IC1 -> XIC1, U1 -> XU1, etc..<br>"

"<li><b>SPICE_VALUE   = ... </b> replaces original value. This new value is also used in "
"auto-includes for sub-circuits. SPICE_INCLUDE however overrides all.<br>"
"If the first character begins with + then the content of the SPICE_VALUE is appended to"
"the existing value, which is useful for adding spice specifics parameters.<br>"

"<li><b>SPICE_MODEL   = ... </b> provides a model. When this attribute is set, auto include will be disabled "
"unless SPICE_INCLUDE is given. This attribute can be used even to describe a complete sub-circuits. "
"Use \ for a new line. Note that in Eagle a model can describe multiple package "
"variant that are distinguished by the technology suffix. It is possible to use part's value for model name as: .model >value ...<br>"

"<li><b>SP_<param> = <value></b>  The Spice Parameter: SP_<param> when non-zero is placed as <param>=<value> "
"a macro inside the SPICE_MODEL block. I.e.: SPICE_MODEL = <b>(gain)</b>, and "
"having defined SP_GAIN=1, will result as <b>(gain=1)</b>. Any number of SP_.. "
"can be used.<br>"

"<li><b>SPICE_PORTS   = </b>Defines a port mapping order, as <b>2 3 1</b> would only shuffle it, or "
"<b>A C</b> to map A to N+ and C to N- of the spice junction diode. "
"Also if a component has 6 pins one may specify to use only <b>4 5 6</b> ignoring the rest. "
"Xspice support vectors where nodes are embraced in brackets [ ]. Use single space "
"as <b>[ A C ] D</b> as a delimiter between bracket symbols and the rest<br>"

"<li><b>SPICE_INCLUDE = ... </b> sets a file to be included with the given part regardless of device type "
"to include spice models or sub-circuits. "
"It also replaces a default value which would be used at X devices.<br>"

"<li><b>SPICE_REM     = ... </b> adds a comment before the component and when used with spice-port "
"in sub-circuit description it adds a separate line for a pin description<br>"

"<li><b>SPICE         = ... </b> ads unique custom string below the part, which string won't repeat "
"if it is the same among many parts<br> "

"<li><b>SPICE_IGNORE</b>    when present the part is ignored, same as SPICE_VALUE=<b>Unused</b> or <b>Open</b>"
"</ul>"
"<hr>"

 
/*
 * Things in my mind for the Future
 * ================================
 * 
 *  - Spice Board Level Integration, add wire resistance and inductance between nodes, capacitances between nets.
 *                       
 *  - optional CodeModel parameters that treat a component as Axxx instead Xxxxx and adds
 *    .model declaration instead of .include; as per .include multiple instances are checked
 *    and also first global spice declaration environment is fed in to over-ride any local
 *    models.
 *         
 *  - Single net elimination from spice list, maybe not needed as ngspice would yield warning
 *
 *
 * ngSpice Installation under Cygwin
 * =================================
 *
 * ./configure --with-x --enable-xspice --enable-cider --enable-pss --disable-debug --with-readline=yes --enable-openmb
 *
 * Make sure to have these libs to have xwin plot function working, as there will be no 
 * warning from the configure
 *  - libX11-devel (this must be there otherwise further checks are skipped and plot just won't work)
 *  - libXaw-devel 
 */
 
string usedString[];        // memorize includes not to double them, and also memorize libs here, basically it could be for anything...
int usedCount = 0;
int subcktMode = 1;         // we assume we're in subkct mode to correctly generate the subckt header


/**
 * Select pins for subcircit by name
 */
string getport_pinname()
{
    if (argc >= 4)
        return strupr(argv[3]);
    return "PIN";
}


/**
 * Is sheet selected for export?
 *
 * Sheet 0 means all.
 */
int is_sheetselected(int number)
{
    if (argc >= 3) {
        if (strtol(argv[2]) == number)
            return number;
        return 0;
    }
    return 1000;
}


/**
 * Is output file given?
 */
string argv_outfile()
{
    if (argc >= 2) 
        return argv[1];
    
    return "";
}

 
/** 
 * Convert net to a lower case string
 *
 * by doing the following transformations
 *  - N$.... -> remove N$ prefix only and leave the net number as it is
 *  - GND -> 0 in top-level mode
 *  - +5V -> dcp5v
 *  - -5V -> dcn5v
 */
string net2str(string name)
{
    if (name == "GND" && !subcktMode)
        return "0";
        
    if (name[0] == '+')
		return strlwr( "dcp" + strsub( name, 1 ) );
    
    if (name[0] == '-')
		return strlwr( "dcn" + strsub( name, 1 ) );
    
    if (strstr(name, "N$") == 0)
		return strlwr( strsub( name, 2 ) );
    
    return strlwr( name );
}
 

/** 
 * Find and write part's net for given pin number
 * 
 * Returns zero when pin is not found.
 */
string printNet(string partname, string pinname)
{
    schematic(SCH) SCH.sheets(SH) SH.nets(N) N.segments(SEG) SEG.pinrefs(P)
    {
        if (P.part.name == partname) {
            P.pin.contacts(C) {
                if (C.name == pinname) return net2str(N.name);
            }
        }
    }
    return "null";
}


/**
 * Find part's attribute and return its value
 *
 * It has some boolean logic to easily control behavior of an attribute from spice:
 *  - If value is undefined the attribute is assumed to be True.
 *  - If value is False (case insensitive), then it returns "", same as undefined
 *  - If attribute is not found, it returns ""
 */
string getAttribute(UL_PART part, string name)
{
    part.attributes( attr )
    {
        if (attr.name == name)
        {   
            if (attr.value == "")
                return "True";
            if ( strlwr(attr.value) == "false")
                return "";
            return attr.value;
        }
    }
    return "";
}


/**
 * Removes default assignments from values, i.e. "{rval}=1k" to "{rval}"
 */
string withoutDefaultValue(string value)
{
    int defaultPos = strstr( value, "}=" );
    
    if ( value[0] == '{' && defaultPos > 1 )
    {
        return strsub(value, 0, defaultPos+1 );
    }
    return value;
}


/**
 * Build a SPICE MODEL with SP_<param>=<value> if part name does not include # character
 *
 * Operate with lower case only
 */
string buildModel(UL_PART part)
{
    string model = getAttribute(part, "SPICE_MODEL");
    if (model == "" || strrchr(part.value, '#') != -1)
        return "";
        
    /*
     * Check for >value before the model ... to replace it with the eagle block value
     */
    int model_value_idx = strstr(strlwr(strsub(model, 0, strchr(model, '('))), ">value", 0);
    if (model_value_idx > 0) {
        model = strsub(model, 0, model_value_idx) + part.value + strsub(model, model_value_idx+6);
    }
        
    /*
     * For each SP_* attribute with a defined value find and replace the string in the model text
     */
    part.attributes( attr )
    {
        if (strsub(attr.name, 0, 3) == "SP_")
        {
            string param = strlwr( strsub(attr.name, 3) );
            
            // start parsing at the first ( search from the end since we only expect [] within model( ... )
            int index = strrchr(model, '(');
            
            while( (index = strstr(strlwr(model), param, index)) != -1 )
            {
                if (index > 0) {
                    if (model[index-1] != ' ' && model[index-1] != '(') {
                        index += strlen(param);
                        continue;
                    }
                }
                
                if (attr.value != "")
                {
                    index += strlen(param);
                    model = strsub(model, 0, index) + "=" + attr.value + strsub(model, index);
                }
                else    // remove undefined parameter from the model list
                {
                    model = strsub(model, 0, index) + strsub(model, index + strlen(param));
                }
            }
            
        }
    }
    return model;
}


/**
 * if first character is a number append up to four 0 at the front to align all possible
 * pad names to 5 digits.
 */
string padded_name(string name)
{
    if (isdigit(name[0])) {
        int i = strlen(name);
        string newname = "";
        for (; i<5; i++) newname += "0";
        return newname + name;
    }
    return name;
}

string unpad_name(string name)
{
    while( name[0]=='0' ) name = strsub(name, 1);
    return name;
}


/** 
 * Print-out part description 
 *
 * TODO: filter out unplaced pins via part.UL_INSTANCE so we can implement
 *       dynamic number of pins for RAM, digital sources, and others.
 */
void describePart(UL_PART part)
{
    string name;
    string value;
    string comment;
    
    /*
     * Check for valid part
     */
    if ( !part) 
        return;        
    if ( !part.device )
        return;
    if ( !part.device.package )
        return;
    if ( strlen(part.value) == 0 ) {
        dlgMessageBox("Part " + part.name + " has no value given and is ignored.\n\nHowever rather set it's value to Open or use SPICE_IGNORE attribute to ignore it.\n");
        return;
    }
    
    /*
     * Add a correct spice prefix to a device name or auto-convert
     *  IC -> X
     */
    if ( (name = strupr(getAttribute(part, "SPICE_DEVICE"))) == "" )
    {
        if (strsub(part.name, 0, 2) == "IC")
            name = "X";
    }    
    name += part.name;
        
    /*
     * Replace or append (when starting with +) the value
     */      
    if ( (value = getAttribute(part, "SPICE_VALUE")) == "" )
        value = part.value;
    else
    {
        if (value[0] == '+')
        {
            value[0] = ' ';
            value = part.value + value;
        }
    }
    
    /* Remove special characters from value, as # which designate ignore model line */
    int hash_idx = strchr(value, '#');
    if (hash_idx >= 0)
        value[hash_idx] = ' ';
        
    /* check for unused and open directives to skip the part */
    string value_lwr = strlwr( value );
    if ( strstr( value_lwr, "open") >= 0 || strstr( value_lwr, "unused" ) >= 0)
        return;
        
    /* check if a contact name exists or it is a dummy object, such as +5V */
    if ( strstr(name, "GND") == 0 || strstr(name, "$") >= 0 ||
         (name[0] == 'P' && (name[1] == '+' || name[1] == '-') ))
        return;
        
    /*
     * Print a remark
     */
    string remark = getAttribute(part, "SPICE_REM");
    if (remark != "")
        printf("\n* %s", remark);
        
    
    /* 
     * Sub-circuit, include a file
     * Check for SPICE_MODEL, or auto include subcircuits
     */
    string include = getAttribute(part, "SPICE_INCLUDE");
    string model = buildModel(part);
    
    if ( (name[0] == 'X' && model == "") || include != "" )
    {
        int index;        
        
        /* Get include file from part's value unless custom is given */
        if ( include == "" ) {
            string a[];
            int n = strsplit(a, value, ' ');
            sprintf(include, "%s.mod", a[0]);
        }
        else
            sprintf(include, "%s", include);
        
        if ( lookup( usedString, include, index ) == "" )
        {
            printf("\n.include %s\n", include);
            usedString[ usedCount++ ] = include;
        }
    }
    
    if ( model != "" )
    {
        int index;
        if ( lookup( usedString, model, index ) == "" )
        {
            usedString[ usedCount++ ] = model;
        
            for (int i=0; i<strlen(model); i++)
                if (model[i] == '\\')
                    model[i] = '\n';
                    
            printf("\n%s\n", model);
        }
    }
    
    /*
     * Describe part
     */
    int pins = 0;
    part.device.package.contacts( contact ) pins++;

    /*
     * If SPICE_PORTS attribute is provided then parse the tokens space separated
     * and find a corresponding pad (contact) names.
     *
     * Otherwise simply list the nets starting with pad (contact) name 1 and so on.
     */
     
    string ports = getAttribute(part, "SPICE_PORTS");
    string contact;
    int contact_valid;
    
    if (ports == "")
    {
        string pads[];
        int pads_count = 0;
        part.device.package.contacts( pad ) {
            pads[pads_count++] = padded_name( pad.name );
        }
        sort(pads_count, pads);
        
        string pad_name_order = "";
        int number_of_named_pins = 0;
        for (int j=0; j<pads_count; j++) {
            if (!isdigit(pads[j][0])) number_of_named_pins++;
            pad_name_order += unpad_name(pads[j]) + " ";
        }
        if (number_of_named_pins) printf("\n* PAD: %s\n", pad_name_order);
        
        printf("%s ", name);
        for (j=0; j<pads_count; j++) {
            printf("%s ", printNet( part.name, unpad_name(pads[j]) ) );
        }
    }
    else
    {
        string ports_pins[];
        int addspace = 0;
        int n = strsplit(ports_pins, ports, ' ');
        
        printf("%s ", name);

        for (int i=0; i < n; i++)
        {
            // Pass through
            if (ports_pins[i]=="[" || ports_pins[i]=="(")
            {
                printf("%s", ports_pins[i]);
                addspace = 0;
            }
            else if (ports_pins[i]=="]" || ports_pins[i]==")")
            {
                printf("%s", ports_pins[i]);
                addspace = 1;
            }
            else
            {
                contact_valid = 0;
                part.device.package.contacts( pad )
                {
                    if (ports_pins[i] == pad.name) {
                        contact_valid = 1;
                        break;
                    }
                }
                if (!contact_valid)
                {
                    dlgMessageBox("Cannot find pin " + ports_pins[i] + " of part " + part.name );
                    exit( EXIT_FAILURE );
                }
                
                if (addspace++ > 0)
                    printf(" ");

                printf("%s", printNet( part.name, ports_pins[i] ) );
            }
        }
        printf(" ");
    }
    
    /*
     * Moves extra notes in values to comments as: 4k7-10V or 4.7k 10V or 4.7k/10V
     * Transform kilo and mega: 2k2 -> 2.2k, 4M7 -> 4.7M, 27R2 -> 27.2
     */
    if (name[0] == 'R' || name[0] == 'C' || name[0] == 'L')
    {
        int i;        
        if ( (i = strchr(value, ' ')) > 0) {comment = strsub(value, i+1); value = strsub(value, 0, i);}
        if ( (i = strchr(value, '-')) > 0) {comment = strsub(value, i+1); value = strsub(value, 0, i);}
        if ( (i = strchr(value, '/')) > 0) {comment = strsub(value, i+1); value = strsub(value, 0, i);}
        if ( (i = strchr(value, ',')) > 0) {comment = strsub(value, i+1); value = strsub(value, 0, i);}
        
        if ( (i = strchr(value, 'k')) > 0) {
            if (isdigit(value[i+1])) {
                value[i] = '.';
                value += "k";
            }
        }
        if ( (i = strchr(value, 'M')) > 0) {
            if (isdigit(value[i+1])) {
                value[i] = '.';
                value += "M";
            }
        }
        if ( (i = strchr(value, 'R')) > 0) {
            if (isdigit(value[i+1])) {
                value[i] = '.';
            }
        }
    }
        
    /*
     * Process value: if it is a resistor, so starting with the letter Rxxx, then:
     *  - check if value ends with a letter R, remove it
     *  - big M must be converted to MEG, and small m remains as mili
     */     
    if (name[0] == 'R')
    {
        int last_i = strlen(value)-1;
        if (value[ last_i ] == 'R' || value[ last_i ] == 'r')
            value[ last_i ] = ' ';
    }
    if (name[0] == 'R' || name[0] == 'C' || name[0] == 'L')
    {
        int last_i = strlen(value)-1;
        if (value[ last_i ] == 'M') value += "eg" ;// small 'm' means mili
    }
    
    printf("%s", withoutDefaultValue( value ) );
    if (comment != "")
        printf(" $ %s\n", comment);
    else
        printf("\n");
    
    /*
     * Add custom output
     */

    string add = getAttribute(part, "SPICE");
    int index_add;
    
    if (add != "" && lookup( usedString, add, index_add ) == "" )
    {
        printf("%s\n", add);
        usedString[ usedCount++ ] = add;
    }
    
    if (remark != "")
        printf("\n");
}


/** 
 * Generate DC sources from net labels
 *
 * This feature is only enabled in top-level circuit mode, and not in
 * subcircuit mode, in which it is treated as usual net.
 */
void generateDCs()
{
    string net;

    schematic(SCH) SCH.sheets(sht) {
        if ( !is_sheetselected(sht.number) ) continue;
        
        sht.nets(N) N.segments(SEG) {
            net = N.name;
            if (net[0] == '+' || net[0] == '-')
            {
                int index;
                string dc_source;
                
                net = net2str(net);
                sprintf(dc_source, "V%s %s 0 DC %s", net, net, N.name);
                
                if ( lookup( usedString, dc_source, index ) == "" )
                {            
                    printf("%s\n", dc_source);
                    usedString[ usedCount++ ] = dc_source;				
                }
                
            }
        }
    }
}


/**
 * Extract schematics name and cut full path prefix and .sch suffix
 */
string getSubcircuitModelName(string fullpath)
{
    int endpos   = strstr(  fullpath, ".sch" );
    int startpos = strrchr( fullpath, '/', endpos ) + 1;

    return strsub( fullpath, startpos, endpos - startpos );
}


/**
 * If there is a sub-circuit symbol spice-port then create a sub-circit header
 *
 * Valid part name is: spice-port
 *
 * \returns subcircuit header
 */
string generateSubcircuit(string designname)
{    
    int pins = 0;
    int index[];
    int pin[];
    string pinname[];
    string value[];
    string desc[];
    string params;

    schematic(sch) {
        sch.sheets(sht) {
            if ( !is_sheetselected(sht.number) ) continue;
            
            sht.parts(part) {
                /*
                 * Extract in order PIN1, PIN2, ... and take out Value as PIN description, 
                 * and the net it is connected to.
                 */
                 
                if ( part.device.name == "SPICE-PORT" && getAttribute(part, "SPICE_IGNORE") == "")
                {
                    int len = strlen(getport_pinname());
                    
                    if ( strsub(part.name,0,len) != getport_pinname() )
                        continue;
                    
                    pinname[pins]  = part.name;
                    pin[pins]      = strtol( strsub(part.name,len) );
                    if ( pin[pins] == 0 )
                    {
                        dlgMessageBox(":FIXME: Cannot correctly sort pin " + part.name );
                        exit( EXIT_FAILURE );
                    }
                    value[pins] = part.value;
                    desc[pins]  = getAttribute(part, "SPICE_REM");
                    pins++;
                    
                    /*
                     * Check if a net with that name exists, otherwise report error
                     */

                    int found = 0;
                    sch.sheets(sht) {
                        if ( !is_sheetselected(sht.number) ) continue;
                        sht.nets(N) {
                            if ( N.name == strupr( part.value ) )
                            {
                                found = 1;
                                break;
                            }
                        }
                    }
                    
                    if (found == 0)
                    {
                        dlgMessageBox(":Sub-circuit port " + part.name + " is assigned to a net " + part.value + 
                            " which does not exist in a circuit.");
                        exit( EXIT_FAILURE );
                    }                
                }
                
                /*
                 * Extract all parameters of format {...}
                 */
                string param = getAttribute(part, "SPICE_VALUE");
                if (param == "")
                    param = part.value;
                    
                int paramDefaultPos = strstr( param, "}=" );
                
                if ( param[0] == '{' && paramDefaultPos > 1 )
                {
                    // convert "{rval}=1k" to "rval=1k"
                    params += " " + strsub( param, 1, paramDefaultPos-1 ) + "=" + strsub( param, paramDefaultPos+2);
                }
            }
        }
        
        sort(pins, index, pin, pinname, value);
        
        if (pins)
        {
            string ports;
            string description = "* Pin Description:\n";
            for (int i=0; i<pins; i++)
            {
                string net = net2str( value[index[i]] );
                sprintf(description,  "%s*\t%s.\t%10s\t%s\n", description, pinname[index[i]], net, desc[index[i]] );
                sprintf(ports, "%s %s", ports, net );
            }
            if (designname == "") designname = getSubcircuitModelName(sch.name);
            return description + "*\n.subckt " + designname + ports + params;
        }
        return "";
    }
}


/**
 * Find a ngSpice Layer
 */
int findSpiceLayer(string name, string alt_name, string alt_name2)
{
    schematic(sch) sch.layers(L)
    {        
        if ( (strlwr(L.name) == name) || (strlwr(L.name) == alt_name) || (strlwr(L.name) == alt_name2) )
        {       
            return L.number;
        }
    }
    return -1;
}


/**
 * Include external module via module instance and SPICE-XPORT
 *
 * - scan for spice-xport and bind nets to pin numbers
 * - add params at the end
 *
 * TODO:
 *  - add bus to represent a vector
 */
void instModules(UL_SCHEMATIC sch, UL_SHEET sht)
{
    sht.moduleinsts(mi)
    {                
        printf("* Processing module %s from sheet %d: \n", mi.name, mi.sheet);
        int ports = 0;
        char model = 'X';
                
        int spiceLayer = findSpiceLayer("ngspice", "ngspice-control", "spice");
        if (spiceLayer > -1)
        {
            mi.module.sheets(msht) msht.texts(txts) {
                if (txts.layer == spiceLayer) {
                    int index;
                    if (strstr(strlwr(txts.value), ".model") >= 0)
                        model = 'A';
                        
                    if (lookup(usedString, strlwr(txts.value), index) == "")
                    {
                        printf("%s\n", txts.value);
                        usedString[ usedCount++ ] = strlwr(txts.value);
                    }
                }
            }
        }
                
        printf("%c%s ", model, strlwr(mi.name) );
        
        mi.module.parts(part) {
            if ( part.device.name == "SPICE-XPORT" ) {
            
                if (strlen(part.value)==0) {
                    dlgMessageBox(":Spice-xport " + part.name + " of module " + mi.module.name + " must have value defined.\n\nAssign it a net name.");
                    exit(1);                    
                }
            
                int found = 0;
                ports++;
            
                /* find net that is connected to this port */
                //printf("%s ", part.value);
                sch.sheets(SH) SH.nets(N) {
                    N.segments(SEG) {
                        SEG.portrefs(P) {
                            if (P.moduleinst.name == mi.name && strupr(part.value) == P.port.name) {
                                //printf("\tNet %s connected to: %s, %s\n", N.name, P.moduleinst.name, P.port.name);
                                printf("%s ", net2str(N.name) );
                                found = 1;                                
                            }
                        }
                    }
                }
                
                if (found == 0)
                    printf("null ");
            }
            else {
                dlgMessageBox(":Component " + part.name + " of module " + mi.module.name + " is not supported.\n\nThis version supports spice-xport from ngspice.lbr only.");
                exit(1);                    
            }
        }
        
        printf("%s\n\n", mi.module.name);
        
        if (ports == 0) {
            dlgMessageBox(":Module " + mi.module.name + " has none of the spice-xports from ngspice.lbr placed.");
            exit(1);
        }
    }
}


/**
 * Returns schematics basic information, title and authors
 * to be printed as the first line in the spice output file
 *
 * TITLE is mandatory, followed by AUTHOR and CONFIRMED responsible.
 * The DOCNUM is optional placed in bracked after TITLE.
 */
string getTitleAuthors()
{
    string title;
    string docnum;
    string author;
    string confirmed;
    string sheetnum;
    
    schematic(sch) sch.attributes(attr)
    {
        if (attr.name == "TITLE" && strlen(attr.value)>2)
            title = attr.value;
        
        if (attr.name == "DOCNUM" && strlen(attr.value)>2)
            docnum = " (" + attr.value + ")";
        
        if (attr.name == "AUTHOR" && strlen(attr.value)>2)
            author = " by " + attr.value;
            
        if (attr.name == "CONFIRMED" && strlen(attr.value)>2)
            confirmed = ", " + attr.value;
    }
    
    if (argc >= 3)
        sheetnum = " Sheet " + argv[2] + " ";
    
    return title + sheetnum + docnum + author + confirmed + "\n";
}


int ignoreMsgShown = 0;

void showIgnoredMsg() {
    if (ignoreMsgShown == 0) {
        printf( "* List of Ignored and Modified Components:\n*\n");
        ignoreMsgShown = 1;
    }
}


/** 
 * Schematics Main generates a mixed-signal ngspice top-level (.cir) or sub-circuit (.mod) file.
 */
schematic(sch)
{
    string designname    = argv_outfile();
    string subckt_header = generateSubcircuit( designname );
    string outfilename;
        
    subcktMode = (subckt_header == "") ? 0 : 1;
        
    if (designname != "")
        outfilename = filesetext(designname, subckt_header == "" ? ".cir" : ".mod");
    else
        outfilename = filesetext(sch.name, subckt_header == "" ? ".cir" : ".mod");
    
    output( outfilename )
    {
        printf("%s%s\n", subckt_header == "" ? "" : "* ", getTitleAuthors() );
        printf("* The %s ngspice netlist was auto-generated on %s\n", getSubcircuitModelName(sch.name), t2string( time() ));
        printf("* with ngspice.ulp V1.3 for Eagle 6.5.0 - 7.7 by Uros Platise, http://www.isotel.eu/mixedsim\n*\n%s\n\n", subckt_header);
                
        sch.sheets(sht) {
            if ( !is_sheetselected(sht.number) ) continue;
            sht.parts(part) {
                if ( getAttribute(part, "SPICE_IGNORE") != "" && part.device.name != "SPICE-PARAM" ) {
                    showIgnoredMsg();
                    printf("* - %s: SPICE_IGNORE\n", part.name);
                }            
                string val;
                if ( (val=getAttribute(part, "SPICE_VALUE")) != "" ) {
                    showIgnoredMsg();
                    printf("* - %s: SPICE_VALUE = %s\n", part.name, val);
                }
            }
        }
        if (ignoreMsgShown) printf("\n");
        
        sch.sheets(sht) {
            if ( !is_sheetselected(sht.number) ) continue;

            /*
             * NgSpice Control Directives what comes to the end
             */

            int spiceLayer = findSpiceLayer("ngspice-init", "ngspice-start", "");
            if (spiceLayer > -1)
            {
                printf("* Spice Initialization Directives from Sheet\n");
                sht.texts(txts)
                {
                    if (txts.layer == spiceLayer)
                        printf("%s\n", txts.value);
                }
            }
            
            /*
             * Top circuit: Write down controllable parameters which are exported as parameter in subcircuit
             */
            if (subckt_header == "") {
                sht.parts(part) {
                    if (part.device.name == "SPICE-PARAM") {
                        string param = part.value;
                        int pos = strchr(param, '{');
                        if (pos >= 0) param[pos] = ' ';
                        if ((pos = strchr(param, '}')) >= 0) param[pos] = ' ';
                        
                        printf(".param %s\n", param);
                    }
                }
            }

            /*
             * Write down all parts, sources, followed by spice additional text from the ngspice layer
             */

            sht.parts(part)
            {            
                // Ignore sub-circuit ports and on user request
                if ( part.device.name != "SPICE-PORT" && getAttribute(part, "SPICE_IGNORE") == "" )
                    describePart(part);
            }

            printf("\n");
            
            /*
             * Process Instantiation of External Modules
             */
             
            instModules(sch, sht);
            
            /*
             * Generate Sources
             */
             
            if ( subckt_header == "" )
            {
                printf("* Auto Generated Sources\n");
                generateDCs();
                printf("\n");
            }
            
            /*
             * NgSpice Control Directives what comes to the end
             */

            spiceLayer = findSpiceLayer("ngspice", "ngspice-control", "spice");
            if (spiceLayer > -1)
            {
                printf("* Spice Control Directives from Sheet\n");
                sht.texts(txts)
                {
                    if (txts.layer == spiceLayer)
                        printf("%s\n", txts.value);
                }
            }
        }
        
        /*
         * Terminate top-level circuit or close sub-circuit
         */
        
        if ( subckt_header == "" )
        {
            printf(".end\n");
            status("Successfully generated top-level simulation to: " + outfilename);
            
        }
        else
        {
            printf(".ends\n");
            status("Successfully generated sub-circuit to: " + outfilename);
        }
    }
}
